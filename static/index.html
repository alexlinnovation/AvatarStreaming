<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Avatar Speak</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }

    /* avatar feed */
    #video      { width: 800px; height: 600px; background:#000; display:block; margin-bottom:10px; }

    /* self-view overlay */
    #self-wrap  {
      position:absolute; right:20px; top:20px;
      width:160px; text-align:center; color:#fff; font-weight:bold;
      text-shadow:0 0 3px #000;
    }
    #self       { width:160px; height:120px; background:#222; border-radius:4px; }

    /* controls */
    input[type=text]{ width:300px; }
    button      { margin:5px; padding:5px 10px; }
  </style>
</head>
<body>
  <h2>Digital Avatar</h2>

  <!-- avatar video + self overlay in same relative box -->
  <div style="position:relative; display:inline-block;">
    <video id="video" autoplay playsinline></video>

    <!-- local cam + name -->
    <div id="self-wrap">
      <div id="name-label"></div>
      <video id="self" autoplay muted playsinline></video>
    </div>
  </div>

  <br/>
  <input type="text" id="user-name" placeholder="Your name…" />
  <br/>
  <input type="text" id="text" placeholder="Enter text..." />
  <button onclick="connect()">Connect</button>
  <button onclick="sendSpeak()">Speak</button>

  <script>
    let pc = null;
    let sessionId = null;

    /* ── local webcam preview ───────────────────────── */
    navigator.mediaDevices.getUserMedia({ video:true, audio:false })
      .then(s => { document.getElementById('self').srcObject = s; })
      .catch(e => console.warn('cam err', e));

    /* update name label live */
    document.getElementById('user-name').addEventListener('input', ev => {
      document.getElementById('name-label').textContent = ev.target.value.trim();
    });

    /* ── your original connect() (unchanged) ────────── */
    async function connect() {
        try {
            pc = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { 
                        urls: 'stun:relay1.expressturn.com:3478',
                        username: 'efTYZ01RL1QUJ5CFUX',
                        credential: 'AOZVt0YaAPWCJPbQ'
                    },
                    { 
                        urls: 'turn:relay1.expressturn.com:3478',
                        username: 'efTYZ01RL1QUJ5CFUX',
                        credential: 'AOZVt0YaAPWCJPbQ'
                    }
                ],
                iceTransportPolicy: 'all',
                bundlePolicy: 'balanced',
                rtcpMuxPolicy: 'require'
            });

            pc.addTransceiver('video', { direction: 'recvonly' });
            pc.addTransceiver('audio', { direction: 'recvonly' });

            pc.onconnectionstatechange = () => {
                console.log("Connection state:", pc.connectionState);
                if (pc.connectionState === 'connected')  console.log("✅ Fully connected");
                if (pc.connectionState === 'failed')     console.error("❌ Connection failed");
            };

            pc.ontrack = (e) => {
                const v = document.getElementById("video");
                if (v && e.streams[0] && !v.srcObject) {
                    v.srcObject = e.streams[0];
                    v.play().catch(err => console.log("play err", err));
                }
            };

            await pc.setLocalDescription(await pc.createOffer());
            await new Promise(r => {
                const t = setTimeout(r, 8000);
                pc.onicecandidate = ev => { if (!ev.candidate){ clearTimeout(t); r(); } };
            });

            const reply = await fetch("/offer", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ sdp: pc.localDescription.sdp, type: pc.localDescription.type })
            });

            const ans = await reply.json();
            await pc.setRemoteDescription(new RTCSessionDescription(ans));
            sessionId = ans.sessionid;
        } catch (err) { console.error("Connection error:", err); }
    }

    async function sendSpeak() {
      const text = document.getElementById("text").value;
      try {
        await fetch("/speak", {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: new URLSearchParams({ sessionid: sessionId, text, voice_style: "af_heart", speed: "1.1" })
        });
      } catch (e) { console.error("Error sending text:", e); }
    }
  </script>
</body>
</html>
